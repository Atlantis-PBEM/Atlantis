// @ts-ignore - Since we are running using parcel, these imports will be resolved
import Color from 'color'
// @ts-ignore - Since we are running using parcel, these imports will be resolved
import Alpine from 'alpinejs'
// @ts-ignore -- This file is generated by the game engine and should be available before running
import hexdata from './hexmap.json'
import { Point, DoubledCoord, Layout } from './hex'

declare global {
    interface Window {
        Alpine: typeof Alpine
    }
}
window.Alpine = Alpine

// registering a global store
Alpine.store('global', {
    'resource': '',
    'resources': [
        { title: 'None', value: ''},
        { title: 'Admantium', value: 'admantium'},
        { title: 'Floater', value: 'floater'},
        { title: 'Mithril', value: 'mithril'},
        { title: 'Yew', value: 'yew'},
        { title: 'Wing', value: 'wing'},
    ],
    'features': [
        { title: 'Gate', checked: false },
        { title: 'Shaft', checked: false },
        { title: 'Starting Area', checked: false },
    ]
});

Alpine.start()

const canvas = document.getElementById('map') as HTMLCanvasElement;
// This is just forcing typescript below to not believe we could have null
// here.  If we have a null here we have other issues.
const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;

type Region = typeof hexdata["surface"][0];

const taiga = Color('#4ba666');
const jungle = Color('#177832');
const grassland = Color('#91e069');
const desert = Color('#f0d735');

const TERRAIN = {
  'ocean': '#00008b',
  'plain': '#bfb370',
  'forest': '#228B22',
  'mountain': '#704214',
  'swamp': '#667c26',
  'jungle': '#254117',
  'desert': '#c58917',
  'tundra': '#99afbc',
  'volcano': '#622f22',
  'lake': '#6698ff',
  'barren': '#302020',
  'underforest': '#1f4d2b',
  'cavern': '#7d4d7d',
  'tunnels': '#9d4d4d',
  'chasm': '#4d9d9d',
}

const CELL_SZ = 5
const MAP_W = 196
const MAP_H = 196
const MAP_GAP = 32

function drawHexMap(col: number, row: number, level: string) {
    const offsetX = col * (MAP_W * CELL_SZ + MAP_GAP) + 50;
    const offsetY = row * (MAP_H * CELL_SZ + MAP_GAP) + 50;

    const layout = new Layout(Layout.flat, new Point(CELL_SZ * 2, CELL_SZ * 2.25), new Point(offsetX, offsetY));
    const globals = Alpine.store('global');

    for (const item of hexdata[level]) {
        const p = new DoubledCoord(item.x, item.y).qdoubledToCube();
        const points = layout.polygonCorners(p);

        ctx.fillStyle = TERRAIN[item.terrain] || 'red';
        ctx.beginPath();
        let first = true;
        for (const n of points) {
            if (first) ctx.moveTo(n.x, n.y); else ctx.lineTo(n.x, n.y);

            first = false;
        }
        ctx.closePath();
        ctx.fill();

        // Draw small circles for gate & starting area.
        const point = layout.hexToPixel(p);
        // Draw a circle for the gate (in white)
        if (item.gate && globals.features.find(f => f.title === 'Gate').checked) {
            ctx.beginPath();
            ctx.fillStyle = 'yellow';
            ctx.arc(point.x - 3, point.y - 3, 2, 0, Math.PI*2);
            ctx.fill();
        }
        if (item.starting && globals.features.find(f => f.title === 'Starting Area').checked) {
            // Draw a circle for starting area (in yellow)
            ctx.beginPath();
            ctx.fillStyle = 'red';
            ctx.arc(point.x + 3, point.y + 3, 2, 0, Math.PI*2);
            ctx.fill();
        }
        if (item.shaft && globals.features.find(f => f.title === 'Shaft').checked) {
            // Draw a circle for shaft (in yellow)
            ctx.beginPath();
            ctx.fillStyle = 'black';
            ctx.arc(point.x + 3, point.y - 3, 2, 0, Math.PI*2);
            ctx.fill();
        }

        if (globals.resource !== '' && item[`${globals.resource}`]) {
            ctx.beginPath();
            ctx.fillStyle = 'white';
            ctx.arc(point.x - 3, point.y + 3, 2, 0, Math.PI*2);
            ctx.fill();
        }

        const corner_to_exit = [1, 0, 5, 4, 3, 2]
        // Draw the edges/exits
        for (const [n, point] of points.entries()) {
            // Edge is from n to n+1 and 0->1 maps to NE, 1->2 to N, 2->3 to NW, 3->4 to SW, 4->5 to S, 5->0 to SE
            const n1 = (n + points.length + 1) % points.length;
            if(item.exits && (item.exits[corner_to_exit[n]] === false)) {
                ctx.beginPath();
                ctx.strokeStyle = 'red';
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(points[n1].x, points[n1].y);
                ctx.stroke();
            }
        }
    }
}

function draw() {
    drawHexMap(0, 0, "surface");
    drawHexMap(0, 1, "underworld1");
}

// wraps draw in an Alpine effect so it will be called whenever the resources store changes
Alpine.effect(draw)
